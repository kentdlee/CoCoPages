<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0043)http://docs.python.org/3.2/library/dis.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    
<title>CoCo - A Python Virtual Machine</title>
    <link rel="stylesheet" href="./index_files/pydoctheme.css" type="text/css">
    <link rel="stylesheet" href="./index_files/pygments.css" type="text/css">

    <style type="text/css">
<!--
.style3 {font-size: 100%}
-->
    </style>
    </head>
  <body>
      <div class="document">

  <div class="documentwrapper">
<div class="sidebar">
      <h2><a href="index.html">The CoCo VM</a></h2>
    <p><a href="#downloads">Download</a></p>
    <p><a href="disassembler.py">Python Disassembler</a></p>
    <p><a href="#overview">Overview</a></p>
    <p><a href="#usage">Usage</a></p>
      <ul>
        <li><a href="#example1">Example 1</a></li>
        <li><a href="#example2">Example 2</a></li>
      </ul>
      <p><a href="#syntax">Syntax</a></p>
    <p><a href="#types">Types</a></p>
      <p><a href="#magic">Magic Methods</a></p>
      <p><a href="#globals">Built-in Functions</a></p>
    <p><a href="#instructions"> Instructions</a></p>
      <ul>
        <li><a href="#arithmetic">Arithmetic</a></li>
        <li><a href="#loadstore">Load and Store</a></li>
        <li><a href="#liststuples">Lists and Tuples</a></li>
        <li><a href="#stack">Stack Manipulation</a></li>
        <li><a href="#conditionals">Conditions/Loops</a></li>
        <li><a href="#functions">Functions</a></li>
      </ul>
    </div>
        <div class="bodywrapper">

          <div class="body">
                  
            
  <div class="section" id="module-dis">
<span id="dis-disassembler-for-python-bytecode"></span>
<div class="banner">
<h1>CoCo - A Python Virtual Machine</h1>
<p><strong>Source code:</strong> <a href="http://github.com/kentdlee/CoCo.git">http://github.com/kentdlee/CoCo.git</a></p>
</div>
<p>Welcome to CoCo, a virtual machine based on the Python virtual machine. This virtual machine was implemented in C++. Its was designed for educational purposes for learning C++, assembly language, and higher level language implementation. The entire source for CoCo is available on GitHub free of charge. You may download it by cloning the github repository or by downloading a zip file of the source. A README accompanies the source code repository to tell you how to compile the program. Precompiled binaries for the three major platforms are provided below if you do not have a compiler installed on your computer. </p>
<h2 id="downloads">Download</h2>
<p>You can download CoCo's complete source code from</p>
<p><a href="http://github.com/kentdlee/CoCo.git">http://github.com/kentdlee/CoCo.git</a></p>
<p>Once you have downloaded, you can compile the code by running</p>
<pre>./configure

make
</pre>
<p>If for some reason, that does not work for you, you can rebuild the configure and make files with the rebuild script. However, you will have to have make utilities installed to rebuild. To see if you have the right utilities try this.</p>
<pre>./rebuild

./configure

make</pre>
<p>If that does not work, you can brute force the compile, assuming you have a C++ compiler installed, with this command.</p>
<pre>g++ -g -o coco *.cpp</pre>
<p>If you are going to be working with the source code at all, the above command is not desirable since it will recompile everything every time you make a change and recompile. This can take a little time and could slow down development. It would be better to use make if at all possible. </p>
<p>If you don't have a C++ compiler and just want to try CoCo, you can download a precompiled binary of coco by clicking the links below. You are still encouraged to get the source code as a resource for learning C++. </p>
<ul>
  <li><a href="http://cs.luther.edu/~leekent/CoCo/binaries/Windows/CoCo Setup.exe">Microsoft Windows</a></li>
  <li><a href="http://cs.luther.edu/~leekent/CoCo/binaries/MACOSX/coco">Mac OS X</a></li>
  <li><a href="http://cs.luther.edu/~leekent/CoCo/binaries/Linux/coco">Linux</a></li>
  </ul>
<p>CoCo includes a disassembler that will disassemble certain Python programs into a CoCo assembly language program. To use the disassembler you must have installed Python 3.2 and run the disassembler with Python 3.2. Usually, if you have version 3.2 installed, you can run it by typing python3.2 at the command-line. Your Python program must have a main function with no arguments where execution will begin. The Python program to disassemble may have as many functions as desired, but to be in CoCo format, classes are not supported. </p>
<p>You can <a href="disassembler.py">download the disassembler</a> from here. It is also in the tests subdirectory of the CoCo source code distribution. </p>
<div class="impl-detail compound">
<p><strong><span class="style3">CoCo implementation detail</span>:</strong> Bytecode is an implementation detail of the Python interpreter.  No
guarantees are made that bytecode will not be added, removed, or changed
between versions of Python. For this reason, CoCo is specific to Python 3.2. To use the disassembler that is distributed with this software package, you must have Python 3.2 installed on your system. Use of the disassembler.py module should not be considered to
work across Python VMs or Python releases.</p>
<p>&nbsp;</p>
<p>You can typically install Python 3.2.5 from Linux distributions or MacPorts. If you don't find it under your platform's software management, it can be downloaded from python.org at </p>
<p>&nbsp;</p>
<p><a href="http://www.python.org/download/releases/3.2.5/">http://www.python.org/download/releases/3.2.5/</a></p>
<p>&nbsp;</p>
<p>There are Windows and Mac installers available on this page. For Linux you can download the source and compile and install it. </p>
<p>&nbsp;</p>
<p>CoCo itself is not dependent on Python 3.2. Only the dissassembler is. However, it is highly recommended that you have Python 3.2 installed so you can use the disassembler to learn CoCo assembly language. </p>
</div>
<h2 id="overview">Overview of the CoCo Virtual Machine</h2>
<p>CoCo, like Python, is a virtual machine (i.e. an interpreter) for bytecode instructions. CoCo is written in C++ using object-oriented principles and does not store its instructions in actual bytecode format. Instead, it reads an assembly language file and builds an internal representation of the program as a sequence of functions each with their own sequence of ByteCode objects.</p>
<p>Each function of a CoCo program, when called, results in a new stack frame object being created. A stack frame contains all local variables that are defined in the function. Each stack frame also contains two stacks, an operand stack and a block stack. </p>
<p>The operand stack is used by the virtual machine to store all intermediate results of instruction execution. Operands are popped from the operand stack when an instruction is executed possibly leaving its result on the operand stack for use by a subsequent instruction. This style of computation has been in use a long time, from Hewlett Packard mainframe computers of the 1960's through the 1980's to calculators made by Hewlett Packard still today. The Java virtual machine is a stack machine as is the Python virtual machine. </p>
<p>The other stack is a block stack. The block stack keeps track of exit points for blocks of code within a CoCo program. When a loop is entered, the exit point of the loop is pushed onto the block stack. In this way, if a break instruction is executed inside a loop, the exit point of the loop can be found and the execution of the break instruction will jump to that address. Exception handlers also push the address of the handler onto the block stack. If an exception occurs, execution  jumps to the exception handler by popping the address from the block stack. When a loop or try block is exited, the corresponding block stack address is popped from the block stack. </p>
<p>A program counter (abbreviated PC) is responsible for holding the address of the next instruction to be executed. The machine proceeds by fetching an instruction from the code, incrementing the PC, and executing the fetched instruction. Execution proceeds this way until a RETURN_VALUE instruction is executed or an exception occurs. </p>
<p>When an exception occurs, if no matching exception handler is found,  execution of the function terminates and control is returned to the previously called function where the exception continues to propagate back until a matching exception handler is found. If no matching handler is found, the complete traceback of the exception is printed. </p>
<p>If no exception occurs during the running of a program, execution terminates when the main function executes the RETURN_VALUE instruction. </p>
<h2 id="usage">Usage</h2>
<p>CoCo is a full-fledged virtual machine. It reads a source file in CoCo assembly format and interprets the instructions. CoCo is a interpreter for Python assembly language instructions. In addition, included with CoCo is a Python disassembler that diassembles Python programs into CoCo format. With these two tools together you can learn a lot about not only the syntax of casm files (the extension understood as CoCo assembly language) but also the Python language itself. Two examples below describe the usage of CoCo and the associated disassembler. </p>
<h4 id="example1">Example</h4>
<p>Consider the following Python program. The disassembler is a module found in the tests subdirectory of the source code distribution or <a href="disassembler.py">you can download it here</a>. To disassemble correctly, Python programs must contain a series of functions including a main function. The disassembler is imported at the top. Instead of calling the main function, the disassemble function of the same module is called on each function. </p>
<div class="highlight-python3" style="position: relative;"><div class="highlight">
<pre>import disassembler

def main():
    x = 5
    y = x + 5
    print(y+5)
    
disassembler.disassemble(main)
</pre>
</div>
</div>
<p>Calling the disassembler on the main function in the example above produces this output file. </p>
<div class="highlight-python3" style="position: relative;"><div class="highlight"><pre>
Function: main/0
Constants: None, 5
Locals: x, y
Globals: print
BEGIN
          LOAD_CONST                     1
          STORE_FAST                     0
          LOAD_FAST                      0
          LOAD_CONST                     1
          BINARY_ADD               
          STORE_FAST                     1
          LOAD_GLOBAL                    0
          LOAD_FAST                      1
          LOAD_CONST                     1
          BINARY_ADD               
          CALL_FUNCTION                  1
          POP_TOP                  
          LOAD_CONST                     0
          RETURN_VALUE             
END
</pre></div>
</div>
<p>In the code above there is one function called main. The assembly indicates main has 0 formal parameters. Constants that are used in the code include <strong>None</strong> and 5. There are two local variables in the function: <em>x</em> and <em>y</em>. The global <em>print</em> function is called and so is in the list of <em>globals</em>. Every function in CoCo has at least these categories of identifiers and values within each defined function. Sometimes one or more of these categories may be empty and can be omitted in that case. </p>
<p>The instructions of the code follow the begin keyword and preceed the end keyword. <strong>LOAD_CONST</strong> 1 means to load the constant value at index 1 (zero based) of the <em>constants</em> onto the operand stack. CoCo is a stack machine and therefore all operations are performed with operands pushed and popped from the operand stack. </p>
<p>The <strong>STORE_FAST</strong> instruction stores a value in the locals list, in this case at offset 0, the location of x. <strong>LOAD_FAST</strong> does the opposite, pushing a value on the operand stack from the locals list of variables. <strong>BINARY_ADD</strong> pops two elements from the stack and adds them together, pushing the result. <strong>CALL_FUNCTION</strong> pops the number of arguments specified in the instruction (1 in this case) and then pops the function from the stack. Finally, it calls the popped function with the popped arguments. The result of the function call is left on the top of the operand stack. In the case of the print function, <strong>None</strong> is returned and left on the stack. The <strong>POP_TOP</strong> instruction pops the <strong>None</strong> from the stack and discards it only to have this function push a None on the stack just before returning. <strong>RETURN_VALUE</strong> pops the top argument from the operand stack and returns that value to the calling function. </p>
<p>To run this code, make sure that you have the coco execuatable in your path some place. Then you can execute the following code to try this example.</p>
<pre>cd tests

python3.2 test1.py &gt; test1.casm

coco test1.casm</pre>
<h4 id="example2">A More Complex Example</h4>
<p>CoCo is capable of handling complex functions that may be nested inside one another. It can handle functions that return functions and functions that take other functions as parameters. Consider the following Python program.</p>
<pre>
# If 1 2 3 4 is entered, and 5 for the second prompt
# then the answer should be [6, 13, 20, 27]
from disassembler import *

def main():
    def g(aVal):
        def f(x):
            return aVal + lstInts[0] + x

        return f
    
    x = input("Please enter a list of integers: ")
    lst = x.split()
    
    lstInts = []
    for y in lst:
        lstInts.append(int(y))
    
    myFun = g(6)
    
    print(myFun(lstInts[2]))

#main()
disassemble(main)
</pre>
<p>Calling disassemble on main will disassemble any nested functions as well, so it is only necessary to call disassemble on all top-level functions. You can read the code above and the comments to understand how this program works. The disassembled code appears below.</p>
<pre>
Function: main/0
    Function: g/1
        Function: f/1
        Constants: None, 0
        Locals: x
        FreeVars: aVal, lstInts
        BEGIN
                  LOAD_DEREF                     0
                  LOAD_DEREF                     1
                  LOAD_CONST                     1
                  BINARY_SUBSCR            
                  BINARY_ADD               
                  LOAD_FAST                      0
                  BINARY_ADD               
                  RETURN_VALUE             
        END
    Constants: None, code(f)
    Locals: aVal, f
    FreeVars: lstInts
    CellVars: aVal
    BEGIN
              LOAD_CLOSURE                   0
              LOAD_CLOSURE                   1
              BUILD_TUPLE                    2
              LOAD_CONST                     1
              MAKE_CLOSURE                   0
              STORE_FAST                     1
              LOAD_FAST                      1
              RETURN_VALUE             
    END
Constants: None, code(g), "Please enter a list of integers: ", 6, 2
Locals: g, x, lst, y, myFun
CellVars: lstInts
Globals: input, split, append, int, print
BEGIN
          LOAD_CLOSURE                   0
          BUILD_TUPLE                    1
          LOAD_CONST                     1
          MAKE_CLOSURE                   0
          STORE_FAST                     0
          LOAD_GLOBAL                    0
          LOAD_CONST                     2
          CALL_FUNCTION                  1
          STORE_FAST                     1
          LOAD_FAST                      1
          LOAD_ATTR                      1
          CALL_FUNCTION                  0
          STORE_FAST                     2
          BUILD_LIST                     0
          STORE_DEREF                    0
          SETUP_LOOP               label02
          LOAD_FAST                      2
          GET_ITER                 
label00:  FOR_ITER                 label01
          STORE_FAST                     3
          LOAD_DEREF                     0
          LOAD_ATTR                      2
          LOAD_GLOBAL                    3
          LOAD_FAST                      3
          CALL_FUNCTION                  1
          CALL_FUNCTION                  1
          POP_TOP                  
          JUMP_ABSOLUTE            label00
label01:  POP_BLOCK                
label02:  LOAD_FAST                      0
          LOAD_CONST                     3
          CALL_FUNCTION                  1
          STORE_FAST                     4
          LOAD_GLOBAL                    4
          LOAD_FAST                      4
          LOAD_DEREF                     0
          LOAD_CONST                     4
          BINARY_SUBSCR            
          CALL_FUNCTION                  1
          CALL_FUNCTION                  1
          POP_TOP                  
          LOAD_CONST                     0
          RETURN_VALUE             
END
</pre>
<p>From the code above you can observe several things that are worth a little more explanation.</p>
<ul>
  <li>A nested function appears right after the outer function's <strong>Function:</strong> declaration line. </li>
  <li><strong>FreeVars</strong> is another category of variables in a function. <strong>FreeVars</strong> are variables that are referenced in the function, but not defined within the function. Instead, they are referenced from the enclosing function's scope. </li>
  <li><strong>CellVars</strong> are yet another category of variable. A cellvar is a variable that is local to the function, but is referenced by some other function and therefore must be stored with an indirect reference so it can be referenced in both function. </li>
  <li>The <em>code(g)</em> and <em>code(f)</em> represent the code of function g and the code of function f respectively. The code of a nested function is a constant to the outer function. </li>
  <li>Labels are used to symbolically indicate the targets of jumps and other branching instructions. </li>
</ul>
<h2 id="syntax">Syntax</h2>
<p>The syntax of the CoCo assembly language is pretty well illustrated by the two examples above. The complete syntax of the language is given here as a BNF. There are just a few things to note in the BNF below that weren't illustrated by either example above.</p>
<ul>
  <li>Instructions may have as many labels defined on them as necessary. The definition of labeled instruction is recursive. </li>
  <li>The NULL below indicates an empty production. So a FunctionList may be empty for instance, meaning that there might not be a function list in a function definition. In this case that simply means a function might or might not have some nested functions. </li>
  <li>Of course, the ... indicates there are more Unary and Binary mnemonics that are not listed in the BNF. The complete list of instructions and descriptions of each of them are given below. </li>
  <li>The CoCo language is not line oriented. This BNF completely describes the language which has no line requirements. However, formatting a program like the disassembler  will help in the clarity of the code you are writing. </li>
  </ul>
<pre>CoCoAssemblyProg ::= FunctionListPart EOF

FunctionListPart ::= FunDef FunctionList

FunctionList ::= FunDef FunctionList | NULL

FunDef ::= Function colon Identifier slash Integer FunctionList ConstPart LocalsPart 
              FreeVarsPart CellVarsPart GlobalsPart BodyPart

ConstPart ::= NULL | Constants colon ValueList

ValueList ::= Value ValueRest

ValueRest ::= comma ValueList | NULL

Value ::= None | Integer | Float | String   
          (* the Scanner recognizes None as an Identifier *)
          
LocalsPart ::=  NULL | Locals colon IdList

FeeVarsPart ::=  NULL | FreeVars colon IdList

CellVarsPart ::= NULL | CellVars colon IdList

IdList ::= Identifier IdRest

IdRest ::= comma IdList | NULL

GlobalsPart ::= NULL | Globals colon IdList

BodyPart ::= BEGIN InstructionList END

InstructionList ::= NULL | LabeledInstruction InstructionList

LabeledInstruction ::= 
          Identifier colon LabeledInstruction | Instruction | OpInstruction
          
Instruction ::= STOP_CODE | NOP | POP_TOP | ROT_TWO | ROT_THREE | ...

OpInstruction ::= OpMnemonic Integer | OpMnemonic Identifier

OpMnemonic ::= 
          LOAD_CONST | STORE_FAST | SETUP_LOOP | COMPARE_OP | POP_JUMP_IF_FALSE | ...
</pre>
<h2 id="types">Types</h2>
<p>CoCo supports the following types within the language.</p>
<ul>
  <li>The <strong>type</strong> type is the type of all types, including itself.</li>
  <li>The <strong>NoneType</strong> is the type of None.</li>
  <li>The <strong>bool</strong> is the type of boolean types.</li>
  <li><strong>int</strong> is for integer types (implemented as a C++ int, which may be 32 or 64 bits depending on the compiler you use and platform you are running on.</li>
  <li><strong>float</strong> is the type for floating point numbers (implemented as a double precision floating point number in CoCo).</li>
  <li><strong>str</strong> is the type for all strings.</li>
  <li><strong>str_iterator</strong> is the type for iterators over strings.</li>
  <li><strong>function</strong> is the type of all functions.</li>
  <li><strong>built_in_function_or_method</strong> is the type of all built-in functions or methods.</li>
  <li><strong>range</strong> is the type of range objects.</li>
  <li><strong>range_iterator</strong> is the type of range iterator objects.</li>
  <li><strong>Exception</strong> is the type of all exceptions.</li>
  <li><strong>list</strong> is the type of list objects like the original Python list objects. </li>
  <li><strong>list_iterator</strong> is the type of iterators over lists.</li>
  <li><strong>funlist</strong> is the type of functional list objects. This is a new type not supported in Python with the properties of lists from functional languages that are constructed from a head and a tail. <strong>funlist</strong> values are immutable as opposed to the <strong>list</strong> type. </li>
  <li><strong>funlist_iterator</strong> is the type of iterators over funlists. </li>
  <li><strong>tuple</strong> is type type of tuple objects. Tuples are like lists, but are immutable.</li>
  <li><strong>tuple_iterator</strong> is the type of iterators over tuples.</li>
  <li><strong>code</strong> is the type of code objects (i.e. functions).</li>
  <li><strong>cell</strong> is the type of a reference objects.</li>
  </ul>
<h2 id="magic">CoCo Magic and Attr Methods</h2>
<p>One of the powerful features of the Python language results from  methods being looked up on objects at run-time. This means that new types of objects can easily be added to the language because the virtual machine instructions presented below will polymorphically call the proper methods since lookup happens at run-time. In support of this, CoCo, like Python, has what have traditionally been called magic methods. These methods typically begin and end with two underscores. Magic methods are used by instructions as needed. For instance, the __add__ magic method is used by the BINARY_ADD instruction. </p>
<p>CoCo includes support for all the magic methods that are defined by Python. While support is there for the whole list, not all magic methods are implemented on each type of object. The magic methods that are supported by a type of object are controlled by its type or class definition. When a magic method is called, the magic method is first looked up on the type and if it is supported, the call is made. Otherwise, an IllegalOperationException is raised. The use of magic methods is illustrated below in the descriptions of the CoCo instructions. </p>
<p>The possible magic methods include the following: __cmp__, __eq__, __ne__, __lt__, __gt__, __le__, __ge__, __pos__, __neg__, __abs__, __invert__, __round__, __floor__, __ceil__, __trunc__, __add__, __sub__, __mul__, __floordiv__, __div__, __truediv__, __mod__, __divmod__, __pow__, __lshift__, __rshift__, __and__, __or__, __xor__, __radd__, __rsub__, __rmul__, __rfloordiv__, __rdiv__, __rtruediv__, __rmod__, __rdivmod__, __rpow__, __rlshift__, __rand__, __ror__, __rxor__, __iadd__, __isub__, __imul__, __ifloordiv__, __idiv__, __itruediv__, __imod__,  __ipow__, __ilshift__, __iand__, __ior__, __ixor__, __int__, __long__, __float__, __bool__, __cmplex__, __oct__, __hex__, __index__, __coerce__, __str__, __list__, funlist__, __repr__, __unicode__, __format__, __hash__, __nonzero__, __dir__, __sizeof__, __getattr__, __setattr__, __delattr__, __getattribute__, __len__, __getitem__, __setitem__, __delitem__, __reversed__, __contains__, __missing__, __instancecheck__, __subclasscheck__, __call__, __copy__,         __deepcopy__, __iter__, __next__, __type__, __excmatch__. The last two magic methods are specific to CoCo. The __type__ magic method is called when the type function is called on an object. The __excmatch__ magic method is called when matching an exception in an exception handler. </p>
<p>In addition, some objects have additional methods defined on them that are accessed like traditional method calls on objects. For instance, <strong>str</strong> objects have a <em>split</em> method that can be called to split a string on separator characters. Here is the list of attr methods defined in CoCo: split, append, head, tail, concat. The head and tail methods are not found in Python but are defined in CoCo to support funlist objects which are defined to have a head and a tail. </p>
<h2 id="globals">Global Built-In Functions</h2>
<p>CoCo supports the following globally available built-in functions. </p>
<ul>
  <li><strong>print</strong> is a built-in function that prints a variable number of arguments to standard output, followed by a newline character, and returns <strong>None</strong>, just as print does in Python. The objects passed to print are printed by calling the __str__ magic method on each of them and appending their strings with an extra space between each pair of objects. </li>
  <li><strong>fprint</strong> prints exactly one argument. This is a built-in function that is specific to CoCo and is not part of the standard Python language. It prints its argument by calling the __str__ magic method on the object to convert it to a string. This function returns itself, which can be useful when chaining together print expressions. </li>
  <li><strong>tprint</strong> prints exactly one argument, which may be a tuple, and returns None. tprint can be thought of as tuple print, because if a tuple is provided, the contents of the tuple are printed, separated by spaces, just as <strong>print</strong> does. However, <strong>tprint</strong> takes only one argument which may be a tuple. <strong>print</strong> takes a variable number of arguments. <strong>tprint</strong> is specific to CoCo and is not part of the standard Python language. The values of the tuple are converted to strings using the __str__ magic method on each object. <strong>None</strong> is returned by <strong>tprint</strong>.</li>
  <li><strong>input</strong> is a built-in function that prints its prompt to standard output and returns one line of input as a string, just as input does in Python.</li>
  <li><strong>iter</strong> is a built-in function that constructs and returns an iterator over the object that is passed to it, just as Python's <strong>iter</strong> function works. This is implemented by calling the __iter__ magic method on the object. </li>
  <li><strong>len</strong> is a built-in function that returns the length of the sequence that is passed to it. It does this by calling the __len__ magic method on the object given to it. </li>
  <li><strong>concat</strong> is built-in function that returns a string representation of the elements of its sequence concatenated together. The <strong>concat</strong> function in turn calls the concat method on the object that is passed to it. </li>
  <li><strong>int</strong>, <strong>float</strong>, <strong>str</strong>, <strong>funlist</strong>, <strong>type</strong>, and <strong>bool</strong> are all calls to types. When the type is called, the corresponding magic method of __int__, __float__, __str__, __funlist__, __type__, or __bool__ is called on the object that is passed to it. In this way, the object itself is in charge of how it is converted to the specified type. </li>
  <li><strong>range</strong> is a call to the range type that constructs a range object over the specified range. As in Python, the range function has 1, 2, or 3 arguments passed to it, representing the start, stop, and increment of the range of integer values. The start and increment values are optional. </li>
  <li><strong>Exception</strong> is a call to the exception type that constructs and returns an exception object that may be raised or thrown and caught by an exception handler. </li>
  </ul>

<h2 id="instructions">CoCo  Virtual Machine Instructions</h2>
<p>CoCo implements the following  instructions. These instructions are a subset of the instructions supported by the Python Virtual Machine plus a few extra instructions. There are two minor differences from the Python Virtual Machine.</p>
<ul>
  <li>CoCo instructions each take up exactly one location of space. The Python Virtual Machine uses one or more bytes for each instruction and therefore some instructions are composed of multiple bytes. CoCo does not store its instructions as bytes and therefore each instruction takes exactly one location within the CoCo virtual machine interpreter. </li>
  <li>CoCo branch and jump instructions jump to labeled instructions. When read by the CoCo assembler, the labels are converted to target locations which are always absolute addresses. In the Python Virtual Machine some branch instructions provide absolute addresses to jump to and others provide relative offsets to add to the current program counter. The disassembler provided with CoCo converts all relative and absolute target addresses in jumps and branches to labels for CoCo. This makes disassembled code more readable and compatible with the CoCo format. </li>
  </ul>
<p>Other than these two minor differences, the implementation of the instructions is pretty faithful to a subset of the Python Virtual Machine implementation. The full Python 3.2 instruction descriptions are available here.</p>
<p><a href="http://docs.python.org/release/3.2.5/library/dis.html"><strong>Full Python 3.2 Instruction Definition</strong></a></p>
<p>And here are the CoCo instruction descriptions. Again, this is a subset of the full Python 3.2 instruction set with the addition of a few extra instructions and a couple of minor differences. </p>
<p>In the instructions below TOS refers to the top element on the operand stack. TOS1 refers to the element on the operand stack that is second from the top. TOS2, and so on are similarly defined. </p>
<h3 id="arithmetic">Arithmetic Instructions</h3>
<dl class="opcode">
  <dt id="opcode-BINARY_ADD2"><tt class="descname">BINARY_ADD</tt></dt>
  <dd>
    <p>Implements TOS = TOS1 + TOS by making the call TOS.__add__(TOS1).</p>
  </dd>
  <dt id="opcode-BINARY_SUBTRACT2"><tt class="descname">BINARY_SUBTRACT</tt></dt>
  <dd>
    <p>Implements TOS = TOS1 - TOS by making the call TOS.__sub__(TOS1).</p>
  </dd>
<dt id="opcode-INPLACE_ADD2"><tt class="descname">BINARY_MULTIPLY</tt></dt>
  <dd>Implements TOS = TOS1 * TOS by making the call TOS.__mul__(TOS1).</dd>
  <dt id="opcode-BINARY_FLOOR_DIVIDE"> <tt class="descname">BINARY_FLOOR_DIVIDE</tt></dt>
  <dd>
    <p align="left">Implements TOS = TOS1 // TOS by making the call TOS.__floordiv__(TOS1).</p>
  </dd>
  <dt id="opcode-BINARY_TRUE_DIVIDE"> <tt class="descname">BINARY_TRUE_DIVIDE</tt></dt>
  <dd>
    <p>Implements TOS = TOS1 / TOS by making the call TOS.__truediv__(TOS1).</p>
  </dd>
  <dt id="opcode-BINARY_SUBTRACT"><tt class="descname">INPLACE_ADD</tt></dt>
  <dd>Implements in-place TOS = TOS1 + TOS. Exactly the same as BINARY_ADD by making the call TOS.__add__(TOS1).</dd>
</dl>
<h3 id="loadstore">Load and Store Instructions</h3>
<dl class="opcode">
  <dt id="opcode-STORE_LOCALS2"><tt class="descname">LOAD_CONST</tt><big>(</big><em>consti</em><big>)</big></dt>
  <dd>Pushes co_consts[consti] onto the stack.</dd>
  <dt id="opcode-LOAD_GLOBAL2"><tt class="descname">LOAD_GLOBAL</tt><big>(</big><em>namei</em><big>)</big></dt>
  <dd>
    <p>Loads the global named co_names[namei] onto the stack.</p>
  </dd>
  <dt id="opcode-LOAD_FAST2"><tt class="descname">LOAD_FAST</tt><big>(</big><em>var_num</em><big>)</big></dt>
  <dd>
    <p align="left">Pushes a reference to the local co_varnames[var_num] onto the stack.</p>
  </dd>
  <dt id="opcode-STORE_FAST"> <tt class="descname">STORE_FAST</tt><big>(</big><em>var_num</em><big>)</big></dt>
  <dd>
    <p>Stores TOS into the local co_varnames[var_num].</p>
  </dd>
  <dt id="opcode-STORE_FAST2"><tt class="descname">DELETE_FAST</tt><big>(</big><em>var_num</em><big>)</big></dt>
  <dd>
    <p>This instruction does nothing in CoCo which varies from the Python implementation. The purpose of this instruction seems to be implementation dependent. In the Python Virtual Machine it performs cleanup after an exception has occurred. The handling of exceptions is different in CoCo so this instruction exists to make it work with the disassembler, but it is ignored. </p>
  </dd>
  <dt id="opcode-BINARY_MULTIPLY2"><tt class="descname">BINARY_SUBSCR</tt></dt>
  <dd>Implements TOS=TOS1[TOS]. This instruction provides indexing into a list, tuple, or other object that supports subscripting. This is implemented as TOS1.__getitem__(TOS).</dd>
  <dt id="opcode-INPLACE_ADD3"><tt class="descname">STORE_SUBSCR</tt></dt>
  <dd>Implements TOS1[TOS]=TOS2. This instruction provides indexing into a list or other object that supports subscripting and is mutable. This instruction is implemented by calling TOS1.__setitem(TOS,TOS2).</dd>
  <dt id="opcode-LOAD_FAST3"><tt class="descname">LOAD_CLOSURE</tt><big>(</big><em>i</em><big>)</big></dt>
  <dd>Pushes a reference to the cell contained in slot <em>i</em> of the cell and free
    variable storage.  The name of the variable is co_cellvars[i] if <em>i</em> is
    less than the length of <em>co_cellvars</em>.  Otherwise it is co_freevars[i-len(co_cellvars)].</dd>
  <dt id="opcode-LOAD_DEREF"> <tt class="descname">LOAD_DEREF</tt><big>(</big><em>i</em><big>)</big></dt>
  <dd>
    <p>Loads the cell contained in slot <em>i</em> of the cell and free variable storage.
      Pushes a reference to the object the cell contains on the stack.</p>
  </dd>
  <dt id="opcode-STORE_DEREF"> <tt class="descname">STORE_DEREF</tt><big>(</big><em>i</em><big>)</big></dt>
  <dd>
    <p>Stores TOS into the cell contained in slot <em>i</em> of the cell and free variable
      storage.</p>
  </dd>
  <dt id="opcode-STORE_LOCALS5"><tt class="descname">LOAD_ATTR</tt><big>(</big><em>namei</em><big>)</big></dt>
  <dd>Replaces TOS with getattr(TOS,co_names[namei]). An attribute is usually a method associated with some object.</dd>
  </dl>
<h3 id="liststuples">List and Tuple Instructions</h3>
<dl class="opcode">
  <dt id="opcode-STORE_LOCALS3"><tt class="descname">BUILD_TUPLE</tt><big>(</big><em>count</em><big>)</big></dt>
  <dd>Creates a tuple consuming <em>count</em> items from the stack, and pushes the resulting
    tuple onto the stack.</dd>
<dt id="opcode-BUILD_TUPLE2"><tt class="descname">SELECT_TUPLE</tt><big>(</big><em>count</em><big>)</big></dt>
  <dd>
    <p>Pushes the contents of the tuple with count elements onto the operand stack. The count must match the tuple's size or an illegal operation exception will be thrown. The elments of the tuple are pushed so the left-most element is left on the top of the stack. This instruction is not part of the Python Virtual Machine. It is CoCo specific. </p>
  </dd>
  <dt id="opcode-BUILD_LIST"> <tt class="descname">BUILD_LIST</tt><big>(</big><em>count</em><big>)</big></dt>
  <dd>
    <p align="left">Works as BUILD_TUPLE, but creates a list.</p>
  </dd>
  <dt id="opcode-BUILD_LIST2"><tt class="descname">BUILD_FUNLIST</tt></dt>
  <dd>
    <p>Works as BUILD_TUPLE, but creates a list.</p>
  </dd>
  <dt id="opcode-BUILD_LIST3"><tt class="descname">SELECT_FUNLIST</tt></dt>
  <dd>
    <p>This instruction pushes the head and the tail (which is a funlist) onto the operand stack. The head of the list is left on the top of the operand stack. The tail is below it on the stack. This instruction is CoCo specific.</p>
  </dd>
  <dt><tt class="descname">CONS_FUNLIST</tt></dt>
  <dd>
    <p>Pops two elements from the operand stack. TOS should be a funlist and TOS-1 should be an element. The instruction create a new funlist from the two pieces with TOS-1 the  head and TOS the tail of the new list. It pushes this new list onto the operand stack. This instruction is CoCo specific. </p>
  </dd>
</dl>
<h3 id="stack">Stack Manipulation Instructions</h3>
<dl class="opcode">
<dt id="opcode-POP_TOP">
<tt class="descname">POP_TOP</tt></dt>
<dd><p>Removes the top-of-stack (TOS) item.</p>
</dd>
<dt id="opcode-ROT_TWO">
<tt class="descname">ROT_TWO</tt></dt>
<dd><p>Swaps the two top-most stack items.</p>
</dd>
<dt id="opcode-DUP_TOP">
<tt class="descname">DUP_TOP</tt></dt>
<dd><p>Duplicates the reference on top of the stack.</p>
</dd>
</dl>

<h3 id="conditionals">Conditional and Iterative Execution Instructions</h3>
<dl class="opcode">
  <dt id="opcode-GET_ITER2"><tt class="descname">GET_ITER</tt></dt>
  <dd>
    <p>Implements TOS=iter(TOS).</p>
  </dd>
  <dt id="opcode-BREAK_LOOP2"><tt class="descname">BREAK_LOOP</tt></dt>
  <dd>
    <p>Terminates a loop due to a break statement.</p>
  </dd>
  <dt id="opcode-POP_BLOCK2"><tt class="descname">POP_BLOCK</tt></dt>
  <dd>
    <p>Removes one block from the block stack.  Per frame, there is a  stack of blocks,
      denoting nested loops, try statements, and such.</p>
  </dd>
  <dt id="opcode-POP_EXCEPT"> <tt class="descname">POP_EXCEPT</tt></dt>
  <dd>
    <p>Removes one block from the block stack. The popped block must be an exception
      handler block, as implicitly created when entering an except handler.
      In addition to popping extraneous values from the frame stack, the
      last three popped values are used to restore the exception state.</p>
  </dd>
  <dt id="opcode-END_FINALLY"> <tt class="descname">END_FINALLY</tt></dt>
  <dd>
    <p>Terminates a finally clause.  The interpreter recalls whether the
      exception has to be re-raised, or whether the function returns, and continues
      with the outer-next block.</p>
  </dd>
  <dt id="opcode-COMPARE_OP2"><tt class="descname">COMPARE_OP</tt><big>(</big><em>opname</em><big>)</big></dt>
  <dd>    Performs a Boolean operation. Both TOS1 and TOS are popped from the stack and the boolean result is left on the operand stack after the execution of this instruction.  <em>opname</em> is an integer corresponding to the following comparisons.
    <ul>
      <li>0 :TOS1 &lt; TOS or TOS1.__lt__(TOS)</li>
      <li>1 :TOS1 &lt;= TOS or TOS1.__le__(TOS)</li>
      <li>2 :TOS1 = TOS or TOS1.__eq__(TOS)</li>
      <li>3 :TOS1 != TOS or TOS1.__ne__(TOS)</li>
      <li>4 :TOS1 &gt; TOS or TOS1.__gt__(TOS)</li>
      <li>5 :TOS1 &gt;= TOS or TOS1.__ge__(TOS)</li>
      <li>6 :TOS1 contains TOS or TOS1.__contains__(TOS)</li>
      <li>7 :TOS1 not in TOS or TOS1.__notin__(TOS)</li>
      <li>8 :TOS1 is TOS or TOS1.is_(TOS)</li>
      <li>9 :TOS1 is not TOS or TOS1.is_not(TOS)</li>
      <li>10 : exception TOS1 matches TOS or TOS1.__excmatch__(TOS)</li>
      </ul>
  </dd>
  
  <dt id="opcode-JUMP_FORWARD"> <tt class="descname">JUMP_FORWARD</tt><big>(</big><em>target</em><big>)</big></dt>
  <dd>
    <p>Sets the Program Counter (PC) to target. </p>
    </dd>
  <dt id="opcode-POP_JUMP_IF_TRUE"> <tt class="descname">POP_JUMP_IF_TRUE</tt><big>(</big><em>target</em><big>)</big></dt>
  <dd>
    <p>If TOS is true, sets the bytecode counter to <em>target</em>.  TOS is popped.</p>
    </dd>
  <dt id="opcode-POP_JUMP_IF_FALSE"> <tt class="descname">POP_JUMP_IF_FALSE</tt><big>(</big><em>target</em><big>)</big></dt>
  <dd>
    <p align="left">If TOS is false, sets the bytecode counter to <em>target</em>.  TOS is popped.</p>
    </dd>
  <dt id="opcode-JUMP_ABSOLUTE"> <tt class="descname">JUMP_ABSOLUTE</tt><big>(</big><em>target</em><big>)</big></dt>
  <dd>
    <p>Set bytecode counter to <em>target</em>.</p>
    </dd>
  <dt id="opcode-FOR_ITER"> <tt class="descname">FOR_ITER</tt><big>(</big><em>target</em><big>)</big></dt>
  <dd>
    <p>TOS is an <a class="reference internal" href="http://docs.python.org/3.2/glossary.html#term-iterator"><em class="xref std std-term">iterator</em></a>.  Call its __next__() method.
      If this yields a new value, push it on the stack (leaving the iterator below
      it).  If the iterator indicates it is exhausted TOS is popped, and the
      PC is set to<em> target</em>.</p>
    </dd>
  <dt id="opcode-LOAD_GLOBAL"><tt class="descname">SETUP_LOOP</tt><big>(</big><em>target</em><big>)</big></dt>
  <dd>Pushes a block for a loop onto the block stack.  The block spans from the
    current instruction to <em>target</em>.</dd>
  <dt id="opcode-SETUP_EXCEPT"> <tt class="descname">SETUP_EXCEPT</tt><big>(</big><em>target</em><big>)</big></dt>
  <dd>
    <p>Pushes a try block from a try-except clause onto the block stack. <em>target</em> points
      to the first except block.</p>
    </dd>
  <dt id="opcode-SETUP_FINALLY"> <tt class="descname">SETUP_FINALLY</tt><big>(</big><em>target</em><big>)</big></dt>
  <dd>
    <p>Pushes a try block from a try-except clause onto the block stack. <em>target</em> points
      to the finally block.</p>
    </dd>
  <dt id="opcode-LOAD_FAST"><tt class="descname">RAISE_VARARGS</tt><big>(</big><em>argc</em><big>)</big></dt>
  <dd>This instruction varies from the Python version slightly. In CoCo the argc must be one. This is because exceptions in CoCo automatically contain the traceback which is not necessarily the case in the Python Virtual Machine. The argument on the stack should be an exception. The exception is thrown by this instruction.</dd>
</dl>
<h3 id="functions">Function Execution Instructions</h3>
<dl class="opcode">
<dt id="opcode-COMPARE_OP"><tt class="descname">RETURN_VALUE</tt></dt>
<dd>Returns with TOS to the caller of the function.</dd>
<dt id="opcode-COMPARE_OP"><tt class="descname">CALL_FUNCTION</tt><big>(</big><em>argc</em><big>)</big></dt>
<dd>Calls a function.  The low byte of <em>argc</em> indicates the number of positional
  parameters, the high byte the number of keyword parameters. On the stack, the
  opcode finds the keyword parameters first.  For each keyword argument, the value
  is on top of the key.  Below the keyword parameters, the positional parameters
  are on the stack, with the right-most parameter on top.  Below the parameters,
  the function object to call is on the stack.  Pops all function arguments, and
  the function itself off the stack, and pushes the return value.</dd>
<dt id="opcode-MAKE_FUNCTION">
<tt class="descname">MAKE_FUNCTION</tt><big>(</big><em>argc</em><big>)</big></dt>
<dd><p>Pushes a new function object on the stack.  TOS is the code associated with the
function.  The function object is defined to have <em>argc</em> default parameters,
which are found below TOS.</p>
</dd>
<dt id="opcode-MAKE_CLOSURE">
<tt class="descname">MAKE_CLOSURE</tt><big>(</big><em>argc</em><big>)</big></dt>
<dd><p>Creates a new function object, sets its <em>__closure__</em> slot, and pushes it on
the stack.  TOS is the code associated with the function, TOS1 the tuple
containing cells for the closure’s free variables.  The function also has
<em>argc</em> default parameters, which are found below the cells.</p>
</dd>
</dl>
</div>
        </div>
  </div>
</div>

</body></html>